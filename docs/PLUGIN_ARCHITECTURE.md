# Plugin Architecture - Implementation Guide

## Overview

This document explains how the Harness Load Testing platform automatically injects control plane integration logic into user test scripts, creating a seamless "blackbox" experience where users only write test scenarios.

---

## Architecture Components

### 1. User Test File (Clean)
**Location**: User-provided, uploaded via API
**Contains**: ONLY test scenarios - no infrastructure code

```python
# users/my_test.py
from locust import HttpUser, task

class MyUser(HttpUser):
    @task
    def test_endpoint(self):
        self.client.get("/api/endpoint")
```

### 2. Harness Plugin (Blackbox)
**Location**: `locust/locust_harness_plugin.py`
**Contains**: ALL control plane integration logic
- Test lifecycle hooks (start/stop)
- Metrics collection and pushing
- Duration monitoring and auto-stop
- Custom web endpoints for run context
- Authentication and error handling

### 3. Script Processor (Automatic Injection)
**Location**: `internal/scriptprocessor/plugin_injector.go`
**Purpose**: Automatically combines user script + plugin at runtime

---

## How It Works

### Current Flow (With Configuration Code)

```
User writes: Test scenarios + Control plane code (150+ lines)
    ↓
Upload to control plane
    ↓
Control plane stores and deploys
    ↓
Locust runs with all code
```

**Problem**: Every test file requires 150+ lines of boilerplate code.

### New Flow (Plugin Architecture)

```
User writes: Test scenarios ONLY (20 lines)
    ↓
Upload to control plane
    ↓
Control plane automatically injects plugin
    ↓
Combined script deployed to Locust
    ↓
Locust runs with full functionality
```

**Benefit**: Users write 90% less code, focusing only on test logic.

---

## Implementation Options

### Option 1: Import-Based (Recommended)

**Deploy plugin as separate file on Locust instance:**

```bash
# On Locust VM
/opt/locust/
  ├── locust_harness_plugin.py  # Installed once
  └── user_tests/
      └── my_test.py              # User's clean test
```

**User's file automatically imports plugin:**
```python
# Auto-injected by control plane
import locust_harness_plugin  # noqa: F401

# User's actual code
from locust import HttpUser, task
class MyUser(HttpUser):
    @task
    def test(self):
        self.client.get("/api/endpoint")
```

**Advantages:**
- ✅ Plugin code is completely hidden from users
- ✅ Plugin can be updated independently
- ✅ No code duplication across tests
- ✅ Clean separation of concerns

**Implementation:**
1. Deploy `locust_harness_plugin.py` to Locust VM once
2. Control plane injects `import locust_harness_plugin` at top of user scripts
3. Locust Python environment finds and loads the plugin automatically

### Option 2: Inline Injection

**Control plane embeds full plugin code into each script:**

```python
# Generated by control plane
# [150 lines of plugin code embedded here]

# User's actual code
from locust import HttpUser, task
class MyUser(HttpUser):
    @task
    def test(self):
        self.client.get("/api/endpoint")
```

**Advantages:**
- ✅ No separate file deployment needed
- ✅ Self-contained scripts

**Disadvantages:**
- ❌ Code duplication across all tests
- ❌ Plugin updates require re-deploying all tests
- ❌ Larger script storage requirements

---

## Deployment Guide

### Step 1: Deploy Plugin to Locust VM

```bash
# On Locust VM
sudo mkdir -p /opt/harness/locust
sudo cp locust_harness_plugin.py /opt/harness/locust/

# Add to Python path
export PYTHONPATH="/opt/harness/locust:$PYTHONPATH"

# Or install as package
cd /opt/harness/locust
pip install -e .
```

### Step 2: Update Control Plane

The control plane now automatically processes user scripts:

**Before storing script revision:**

```go
// internal/api/handlers.go
func (h *Handler) CreateLoadTest(w http.ResponseWriter, r *http.Request) {
    // ... existing code ...
    
    // INJECT PLUGIN IMPORT
    processedScript, err := scriptprocessor.InjectHarnessPluginBase64(req.ScriptContent)
    if err != nil {
        respondError(w, http.StatusBadRequest, "Failed to process script", err)
        return
    }
    
    // Store the processed script (with plugin import)
    scriptRevision := &domain.ScriptRevision{
        ScriptContent: processedScript,  // Now includes plugin import
        // ... rest of fields ...
    }
    
    // ... continue with existing logic ...
}
```

### Step 3: User Experience

**Users upload clean scripts:**

```bash
# User's file: my_test.py
cat > my_test.py << 'EOF'
from locust import HttpUser, task

class MyUser(HttpUser):
    @task
    def test_api(self):
        self.client.get("/api/products")
EOF

# Upload to Harness (control plane handles everything)
harness load-test create \
  --name "My Test" \
  --script my_test.py
```

**Control plane automatically:**
1. ✅ Detects it's a clean user script (no plugin import)
2. ✅ Injects `import locust_harness_plugin` at the top
3. ✅ Stores the enhanced script
4. ✅ Deploys to Locust
5. ✅ Plugin provides all control plane integration

---

## Code Reference

### Plugin Injector

**File**: `internal/scriptprocessor/plugin_injector.go`

```go
// Automatically injects plugin import into user scripts
func InjectHarnessPlugin(userScript string) string {
    if strings.Contains(userScript, "locust_harness_plugin") {
        return userScript  // Already has plugin
    }
    
    // Add import after user's imports
    return insertAfterImports(userScript, "import locust_harness_plugin")
}

// For base64-encoded scripts (API format)
func InjectHarnessPluginBase64(encodedScript string) (string, error) {
    decoded, _ := base64.StdEncoding.DecodeString(encodedScript)
    injected := InjectHarnessPlugin(string(decoded))
    return base64.StdEncoding.EncodeToString([]byte(injected)), nil
}
```

### Plugin File

**File**: `locust/locust_harness_plugin.py`

Contains all control plane integration:
- ✅ Test start/stop event handlers
- ✅ Metrics collection and pushing
- ✅ Duration monitoring with auto-stop
- ✅ Custom Flask endpoints for run context
- ✅ Authentication and error handling

**Size**: ~350 lines (completely hidden from users)

---

## Migration Path

### Existing Tests (With Configuration Code)

**Option 1: Automatic Extraction (Recommended)**

Control plane can detect and strip out plugin code if present:

```go
func StripExistingPluginCode(script string) string {
    // Remove old embedded plugin code if present
    // Then inject new plugin import
}
```

**Option 2: Manual Migration**

Users can easily migrate by removing configuration code:

**Before (150 lines):**
```python
import os, requests, gevent, logging
# [100+ lines of control plane integration]

from locust import HttpUser, task
class MyUser(HttpUser):
    @task
    def test(self):
        self.client.get("/api/endpoint")
```

**After (5 lines):**
```python
from locust import HttpUser, task
class MyUser(HttpUser):
    @task
    def test(self):
        self.client.get("/api/endpoint")
```

---

## Testing the Setup

### 1. Verify Plugin is Accessible

```bash
# On Locust VM
python3 -c "import locust_harness_plugin; print('Plugin loaded!')"
# Output: Locust Harness Plugin loaded successfully
#         Plugin loaded!
```

### 2. Test Plugin Injection

```bash
# On control plane VM
cd /Users/sarthakjain/harness/Load-manager-cli

# Test the injector
go run cmd/test_injector/main.go
```

### 3. Run a Clean Test

```bash
# Create clean test file
cat > test_clean.py << 'EOF'
from locust import HttpUser, task
class TestUser(HttpUser):
    @task
    def test(self):
        self.client.get("/")
EOF

# Upload via API
curl -X POST http://localhost:8080/v1/load-tests \
  -H "Authorization: Bearer api-token" \
  -H "Content-Type: application/json" \
  -d "{
    \"name\": \"Clean Test\",
    \"scriptContent\": \"$(base64 -i test_clean.py)\",
    \"accountId\": \"test-account\"
  }"

# Verify script was enhanced with plugin import
```

---

## Benefits Summary

| Aspect | Before | After |
|--------|--------|-------|
| **User Code** | 150+ lines | 20 lines |
| **User Focus** | Test logic + infrastructure | Test logic only |
| **Maintainability** | Update every test file | Update plugin once |
| **Learning Curve** | Learn control plane API | Learn Locust only |
| **Error Surface** | Users can break integration | Plugin is blackbox |
| **Onboarding Time** | 1-2 hours | 10 minutes |

---

## Next Steps

1. **Deploy plugin** to Locust VM
2. **Update control plane** to use script processor
3. **Test with example** clean script
4. **Migrate existing** tests (optional)
5. **Update documentation** for users

---

## Support

For implementation questions or issues:
- Review `/Users/sarthakjain/harness/Load-manager-cli/docs/USER_GUIDE.md`
- Check example files in `/Users/sarthakjain/harness/Load-manager-cli/locust/examples/`
- See plugin code in `/Users/sarthakjain/harness/Load-manager-cli/locust/locust_harness_plugin.py`
